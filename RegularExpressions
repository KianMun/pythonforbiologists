import re

#finding position of motif in a dna sequence
dna = "ATCGCAAAAAAATTTTTTGGGGGGAATTCAC"
if re.search(r'GAATTC', dna):
    print(dna.find('GAATTC'))

#'|' to find either or character
dna = "ATCGCGAGGACCATTCAC"
if re.search(r"GG(A|T)CC", dna):
    print('found!')

dna = "ATCGCGAATTCAC"
if re.search(r"GC(A|T|G|C)GC", dna):
    print("restriction site found!")
#or as below:
if re.search(r'GC[ATGC]GC', dna):
    print('restriction site found')

#specifying characters that I don't want to match with "^"
if re.search(r"GC[^AT]GC",dna):
    print('restriction site found')
else:
    print('Not found')

dna = 'ATGACGTACGTACGACTG'

#store the match object in the variable m
m = re.search(r"GA[ATGC]{3}AC",dna)
print(m.group(), 'Position in string: ', dna.find(m.group()))


#Capture bits of the pattern by supplying an argument to
# the group method. group(1) will return the bit of the string matched by the
# section of the pattern in the first set of parentheses, group(2) will return the bit
# matched by the second

dna = "ATGACGTACGTACGACTG"

m = re.search(r"GA([ATGC]{3})AC([ATGC]{2})AC", dna)
print('entire match: ', m.group())
print('first bit: ', m.group(1))
print('second bit: ', m.group(2))

#Getting position of a match using 'start' and 'end' methods

#python counts from 0 zero
print('start: ', str(m.start()))
print('end: ', str(m.end()))

#We can get the start and end positions of individual groups by supplying a number
#as the argument to start and end

print('group one start: ', str(m.start(1)))
print('group one end: ', str(m.end(1)))
print('group two start: ', str(m.start(2)))
print('group two end: ', str(m.end(2)))

#Spliting string using regular expression
#Splitting the DNA string whenever a base isn't A, T, G or C
dna_split = "ACTNGCATRGCTACGTYACGATSCGAWTCG"
runs = re.split(r"[^ATGC]", dna_split)
print(runs)

#finding multiple matches - re.findall, re.findall only returns a list of strings, it has no attribute 'start', so it
#won't return a position and will throw an error
dna_findall = "ACTGCATTATATCGTACGAAATTATACGCGCG"
runs_findall = re.findall(r'[AT]{4,100}', dna_findall)
print(runs_findall)

#finding multiple matches with positions using - re.finditer
#re.finditer returns a sequence of match objects
#re.finditer gives more flexibility than findall
dna_finditer = "ACTGCATTATATCGTACGAAATTATACGCGCG"
runs_finditer = re.finditer(r'[AT]{3,100}', dna_finditer)
for match in runs_finditer:
    runs_finditer_start = match.start()
    runs_finditer_end = match.end()
    print("AT rich region from " + str(runs_finditer_start) + " to " + str(runs_finditer_end))
 
#######################################################################################################################################
#Regular Expressions Exercises

import re
gene_acc_names = ['xkn59438', 'yhdck2', 'eihd39d9', 'chdsye847', 'hedle3455', 'xjhd53e', '45da', 'de37dp']

#acc contains '5'
for acc in gene_acc_names:
    if re.search(r"5",acc):
        print('Accession with the number 5: ', acc)

#acc contains 'd or e'
for acc in gene_acc_names:
    if re.search(r"(d|e)",acc):
        print('Accesion with d or e: ', acc)

#acc contains 'd follow by e'
for acc in gene_acc_names:
    if re.search(r"d.*e", acc):
#We have to be careful with our quantifiers, however â€“ at first glance the pattern
#d.+e looks good, but it will fail to match the accession where e follows d directly.
#To allow for the fact that d might be immediately followed by e, we need to use the
#asterisk
        print('Accesion with d follow by e: ', acc) 

#contain the letters d and e in that order with a single letter between them
for acc in gene_acc_names:
    if re.search(r"(d.e)", acc):
        print('Accesion with d and letter in between follow by e: ', acc)
    
#contain both the letters d and e in any order
for acc in gene_acc_names:
    if re.search(r"d.*e", acc) or re.search(r"e.*d", acc):
        print('Accesion with d and e in any order: ', acc)
    
